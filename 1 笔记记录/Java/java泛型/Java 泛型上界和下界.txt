
Java 泛型 <? super T> 中 super 怎么 理解?与 extends 有何不同?...

https://www.zhihu.com/question/20400700

Java中的泛型是不变的，只能通过泛型通配符？http://blog.csdn.net/u014717036/article/details/52234679



泛型通配符 ?
PECS总结：

要从泛型类取数据时，用extends；
要往泛型类写数据时，用super；
既要取又要写，就不用通配符（即extends与super都不用）。



=========================================================================================================
首先，泛型的出现时为了安全，所有与泛型相关的异常都应该在编译期间发现，因此为了泛型的绝对安全，java在设计时做了相关的限制：
List<? extends E>表示该list集合中存放的都是E的子类型（包括E自身），由于E的子类型可能有很多，
但是我们存放元素时实际上只能存放其中的一种子类型（这是为了泛型安全，因为其会在编译期间生成桥接方法<Bridge Methods>该方法中会出现强制转换，
若出现多种子类型，则会强制转换失败），例子如下：
	
	List<? extends Number> list=new ArrayList<Number>();
        list.add(4.0);//编译错误
        list.add(3);//编译错误

	往容器加入的方法失效。


上例中添加的元素类型不止一种，这样编译器强制转换会失败，为了安全，Java只能将其设计成不能添加元素。
虽然List<? extends E>不能添加元素，但是由于其中的元素都有一个共性--有共同的父类，因此我们在获取元素时可以将他们统一强制转换为E类型，我们称之为get原则。

==========================================================================================================

对于List<? super E>其list中存放的都是E的父类型元素（包括E），我们在向其添加元素时，只能向其添加E的子类型元素（包括E类型），这样在编译期间将其强制转换为E类型时是类型安全的，因此可以添加元素，例子如下： List<? super Number> list=new ArrayList<Number>();
        list.add(2.0);
        list.add(3.0);
但是，由于该集合中的元素都是E的父类型（包括E），其中的元素类型众多，在获取元素时我们无法判断是哪一种类型，故设计成不能获取元素，我们称之为put原则。
实际上，我们采用extends，super来扩展泛型的目的是为了弥补例如List<E>只能存放一种特定类型数据的不足，
将其扩展为List<? extends E> 使其可以接收E的子类型中的任何一种类型元素，这样使它的使用范围更广。
List<? super E>同理。

==========================================================================================================

List ：”存的时候只能选一个类型。
“List <? extends Fruit> 意思： List中所有元素都是Fruit的子类(包含本身)，
List <? super    Fruit>  意思： List中所有元素都是Fruit的父类(包含本身)
1、List <? extends Fruit>假设：Fruit有子类A、B、C 
那么 list.add(A);
list.add(B);
list.add(C);
显然错误(不能存多个类)。     

虽然我们现在看的是ABC3个类就会问为什么会把不同类型的存进去，我这样存不就好了。
list.add(A);
list.add(A);
其实这也是错误的，因为在运行之前他可不知道你到底add进去的东西是什么类型，是一样还是不一样，因实例化的时候是 ? 待定。

为了避免类型不同的情况，所以会编译不通过。

2、List <? super Fruit> 假设：Fruit有子类A、B、C 
那么 
list.add(A);
list.add(B);
list.add(C); 
这却是可以的，为什么呢：      
因为他是这么存的：
list.add((Fruit)A);
list.add((Fruit)B); 
自动强转了。
因为 小转大是隐性的，大转小才是强转需要加类型。      

那这里为什么又不能存Fruit的父类呢？ 
因为   见假设1，它是？号，类型代表待定，不跑起来他也不知道你到底存的什么。

所以我们能手动add()进去的数据都必须是绝对安全的(最低级父类:本身)才能通过。所以直接add父类也是不行的。



